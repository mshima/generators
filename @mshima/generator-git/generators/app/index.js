import { createRequire } from 'module';
const require = createRequire(import.meta.url);

import os from 'os';

const { name: PACKAGE_NAME } = require('../../package.json');

const { EOL } = os;

const DEFAULTS = {
  NODE: ['# node.js', 'node_modules'],
};

const DETECT = {
  '.project': [`# Eclipse (detected by ${PACKAGE_NAME})`, '.project', '.settings'],
};

const GENERATOR_REGENERATE = '@mshima/regenerate:app';

import ParentGenerator from '@mshima/yeoman-generator-defaults';

export default class GitAppGenerator extends ParentGenerator {
  constructor(args, options, features) {
    super(args, options, { uniqueGlobally: true, features });
    this.checkEnvironmentVersion('3.3.0');

    this.sections = [DEFAULTS.NODE];
    this.ignores = [];
    this.gitIgnoreFile = this.destinationPath('.gitignore');
  }

  get '#initializing'() {
    return {
      async regenerate() {
        const regenerateGenerator = await this.compose.with(GENERATOR_REGENERATE);

        regenerateGenerator.registerRequired('@mshima/git:app');

        const { enableGithub } = this.options;

        if (enableGithub || this.storage.enableGithub) {
          regenerateGenerator.registerRequired('@mshima/github:app');
          this.storage.enableGithub = undefined;
        }

        regenerateGenerator.registerOptional('@mshima/github:app');
      },
    };
  }

  get '#prompting'() {
    return {};
  }

  get '#configuring'() {
    return {
      loadExisting() {
        let file;
        if (this.fs.exists(this.gitIgnoreFile)) {
          file = this.fs.read(this.gitIgnoreFile).trim();
          this.ignores = this.ignores.concat(file.split(EOL));
        }
      },
      detect() {
        for (const file of Object.keys(DETECT)) {
          if (this.existsDestination(file)) {
            this.sections.push(DETECT[file]);
          }
        }
      },
    };
  }

  get '#default'() {
    return {};
  }

  get '#postWriting'() {
    return {
      gitignore() {
        const generatedText = `# Generated by ${PACKAGE_NAME}`;
        this.fs.write(this.gitIgnoreFile, generatedText);
        const writtenLines = [generatedText];

        let lastLine;
        const writeLine = line => {
          line = line.trim();
          if (lastLine === line) {
            return;
          }

          if (writtenLines.includes(line)) {
            return;
          }

          lastLine = line;
          this.fs.append(this.gitIgnoreFile, line, { trimEnd: false });
          if (line !== '') {
            writtenLines.push(line);
          }
        };

        for (const section of this.sections) {
          for (const line of section) {
            writeLine(line);
          }

          writeLine('');
        }

        if (this.ignores.filter(line => line && line !== '' && !writtenLines.includes(line)).length > 0) {
          writeLine('# Others entries');
        }

        // Next line should not be blank
        lastLine = '';
        for (const line of this.ignores) {
          writeLine(line);
        }

        this.fs.append(this.gitIgnoreFile, '');
      },
    };
  }

  get '#install'() {
    return {};
  }

  get '#end'() {
    return {};
  }

  ignore(...args) {
    this.sections.push(args);
  }
}
